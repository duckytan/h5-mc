# Minecraft H5 Web版 - 项目需求文档

> 版本：2.0  
> 状态：规划中  
> 技术栈：Three.js + TypeScript + Vite  
> 更新日期：2026-02-08

---

## 0. 用户场景

### 典型用户故事

**作为** 玩家  
**我希望** 能够在浏览器中建造和探索  
**以便** 随时随地体验体素建造的乐趣

**作为** 开发者  
**我希望** 项目代码结构清晰、易于维护  
**以便** 快速迭代新功能

### 核心用户流程

```
┌─────────────────────────────────────────────────────────────┐
│                        用户流程图                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│  │ 进入游戏  │ →  │ 生成世界  │ →  │ 自由探索  │             │
│  └──────────┘    └──────────┘    └──────────┘             │
│       │               │               │                    │
│       ↓               ↓               ↓                    │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│  │ 选择模式  │    │ 放置方块  │    │ 与生物互动│             │
│  │生存/创造 │    │ 破坏方块  │    │          │             │
│  └──────────┘    └──────────┘    └──────────┘             │
│       │               │               │                    │
│       └───────────────┴───────────────┘                    │
│                       ↓                                    │
│                ┌──────────────┐                             │
│                │ 保存/分享世界 │                             │
│                └──────────────┘                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 1. 项目愿景

打造一个高性能、可维护、支持多人联机的 Web 版体素沙盒游戏，提供接近原版 Minecraft 的核心体验，同时针对移动端和低配设备进行优化。

---

## 2. 核心功能需求

### 2.1 世界生成

- [ ] 无限地形生成（按需加载）
- [ ] 多生物群系支持（森林、沙漠、平原、雪地等）
- [ ] 地形特征（山脉、河流、洞穴）
- [ ] 可配置的世界种子

### 2.2 方块系统

- [ ] 基础方块（石头、土、木头、沙子、水等）
- [ ] 方块交互（放置、破坏）
- [ ] 方块变体（不同木材、不同石头）
- [ ] 方块物理属性（重力沙子、水流动）

### 2.3 玩家系统

- [ ] 第一人称视角控制
- [ ] 移动（走、跑、跳跃、蹲下）
- [ ] 物品栏管理
- [ ] 生存模式（饥饿值、生命值）

### 2.4 游戏机制

- [ ] 时间系统（昼夜循环）
- [ ] 天气系统（雨天、雪天）
- [ ] 光照系统（方块阴影、火把光照）
- [ ] 生物生成与AI

### 2.5 多人联机

- [ ] WebSocket 实时同步
- [ ] 玩家位置同步
- [ ] 方块变更同步
- [ ] 聊天系统

---

## 3. 技术架构

### 3.1 渲染引擎

```
Three.js
├── VoxelWorld（体素世界管理）
├── ChunkManager（区块管理）
├── SceneManager（场景管理）
└── MaterialManager（材质管理）
```

### 3.2 核心模块

```
src/
├── core/           # 核心引擎
│   ├── VoxelWorld.ts
│   ├── ChunkManager.ts
│   ├── SceneManager.ts
│   └── MaterialManager.ts
├── gameplay/       # 游戏玩法
│   ├── PlayerController.ts
│   └── BlockInteraction.ts
├── world/          # 世界生成
│   └── TerrainGenerator.ts
└── ui/             # 用户界面
    └── GameUI.ts
```

### 3.3 性能优化策略

- [ ] 视锥体剔除（Frustum Culling）
- [ ] 层级细节（LOD）
- [ ] 实例化渲染（Instanced Rendering）
- [ ] 按需加载区块
- [ ] 材质合并
- [ ] Web Worker 地形生成

---

## 4. 非功能需求

### 4.1 性能指标

- [ ] 60 FPS 桌面端
- [ ] 30 FPS 移动端
- [ ] 支持 1000+ 区块可视
- [ ] 首屏加载 < 3 秒

### 4.2 兼容性

- [ ] Chrome / Firefox / Safari / Edge
- [ ] iOS Safari / Android Chrome
- [ ] 响应式 UI

### 4.3 代码质量

- [ ] TypeScript 严格模式
- [ ] ESLint + Prettier
- [ ] 单元测试覆盖率 > 70%
- [ ] 完整的代码文档

---

## 5. 开发里程碑

### Phase 1: 核心引擎（2周）

- [ ] 搭建 Three.js 场景
- [ ] 实现基础方块渲染
- [ ] 玩家移动控制
- [ ] 射线检测交互

### Phase 2: 世界生成（2周）

- [ ] 噪声算法地形生成
- [ ] 多生物群系
- [ ] 按需加载区块
- [ ] 性能优化

### Phase 3: 游戏玩法（2周）

- [ ] 物品栏系统
- [ ] 生存机制
- [ ] 光照系统
- [ ] 天气/时间

### Phase 4: 联机功能（2周）

- [ ] WebSocket 服务端
- [ ] 玩家同步
- [ ] 方块同步
- [ ] 聊天系统

---

## 6. 风险与挑战

| 风险       | 影响           | 缓解措施               |
| ---------- | -------------- | ---------------------- |
| 性能瓶颈   | 移动端卡顿     | LOD、实例化、按需加载  |
| 代码复杂度 | 难以维护       | 模块化、严格类型、测试 |
| 网络同步   | 延迟/冲突      | 乐观更新、冲突解决     |
| 跨域兼容性 | 部分设备不支持 | 特性检测、回退方案     |

### 6.1 验收标准

#### 世界生成

- [ ] 在 Chrome 桌面端生成 1000 区块耗时 < 5秒
- [ ] 生物群系过渡自然（无明显接缝）
- [ ] 种子系统可复现相同地形
- [ ] 支持至少 4 种生物群系

#### 方块系统

- [ ] 支持至少 10 种基础方块
- [ ] 方块放置/破坏延迟 < 100ms
- [ ] 水方块正确流动（至少 3 格扩散）
- [ ] 沙子方块正确受重力影响

#### 玩家系统

- [ ] WASD 移动响应延迟 < 50ms
- [ ] 跳跃高度可配置
- [ ] 物品栏支持至少 9 格
- [ ] 生命值/饥饿值正确变化

#### 性能指标

- [ ] 桌面端 FPS ≥ 60
- [ ] 移动端 FPS ≥ 30
- [ ] 首屏加载 < 3 秒
- [ ] 内存占用 < 500MB

#### 联机功能（Phase 4）

- [ ] 2+ 玩家同时在线
- [ ] 位置同步延迟 < 200ms
- [ ] 方块变更同步延迟 < 500ms
- [ ] 断线重连成功恢复状态

---

## 7. 技术依赖

### 7.1 核心依赖

| 包名         | 版本     | 用途              |
| ------------ | -------- | ----------------- |
| three.js     | ^0.160.0 | 3D渲染引擎        |
| vite         | ^5.0.0   | 构建工具          |
| typescript   | ^5.3.0   | 类型安全          |
| @types/three | ^0.160.0 | Three.js 类型定义 |

### 7.2 可选依赖

| 包名             | 用途             | 必要性           |
| ---------------- | ---------------- | ---------------- |
| simplex-noise    | 地形生成噪声算法 | 推荐             |
| socket.io-client | 多人联机客户端   | Phase 4          |
| socket.io        | 多人联机服务端   | Phase 4          |
| cannon-es        | 物理引擎         | 可选             |
| zstd-wasm        | 数据压缩         | 可选（性能优化） |

### 7.3 开发依赖

| 包名             | 用途       |
| ---------------- | ---------- |
| eslint           | 代码检查   |
| prettier         | 代码格式化 |
| vitest           | 单元测试   |
| @playwright/test | E2E 测试   |

### 7.4 技术选型

#### 渲染技术

| 方面   | 选型                               | 说明                |
| ------ | ---------------------------------- | ------------------- |
| 渲染器 | WebGLRenderer                      | Three.js 默认渲染器 |
| 材质   | MeshLambertMaterial + TextureAtlas | 性能与效果平衡      |
| 光照   | AmbientLight + DirectionalLight    | 支持阴影            |
| 阴影   | PCFSoftShadowMap                   | 软阴影效果          |

#### 数据结构

| 方面     | 选型                                   | 说明           |
| -------- | -------------------------------------- | -------------- |
| 世界存储 | Map<ChunkKey, Uint8Array>              | 区块坐标到数据 |
| 方块数据 | Uint8Array (y _ 32 + x _ 1024 + z)     | 线性存储       |
| 玩家数据 | Object { position, inventory, health } | JSON 可序列化  |

#### 网络协议

| 方面     | 选型                | 说明           |
| -------- | ------------------- | -------------- |
| 传输     | WebSocket           | 实时双向通信   |
| 消息格式 | JSON                | 简单易调试     |
| 压缩     | JSON + zstd（可选） | 大数据传输优化 |

#### 存储方案

| 场景     | 方案         | 限制               |
| -------- | ------------ | ------------------ |
| 短期存档 | LocalStorage | 5MB 限制           |
| 世界存档 | IndexedDB    | 大容量存储         |
| 联机存档 | 服务端数据库 | Redis + PostgreSQL |

---

## 8. 排期估算

### 8.1 里程碑详细规划

| Phase       | 内容       | 预估工时 | 依赖    | 交付物                    |
| ----------- | ---------- | -------- | ------- | ------------------------- |
| **Phase 0** | 项目初始化 | 1人天    | 无      | 完整项目结构、CI/CD       |
| **Phase 1** | 核心引擎   | 2人周    | Phase 0 | Three.js 场景、可移动视角 |
| **Phase 2** | 世界生成   | 3人周    | Phase 1 | 可生成地形、多生物群系    |
| **Phase 3** | 游戏玩法   | 3人周    | Phase 2 | 物品栏、生存机制          |
| **Phase 4** | 联机功能   | 3人周    | Phase 3 | 多人实时同步              |

**总计预估：11-12 人周**

### 8.2 每周目标

```
Phase 1 (第1-2周):
├── W1: 项目搭建、Three.js 场景、基础渲染
├── W2: 玩家控制、射线检测、方块交互

Phase 2 (第3-5周):
├── W3: 噪声算法实现、地形生成
├── W4: 多生物群系、区块加载
├── W5: 性能优化（LOD、剔除）

Phase 3 (第6-8周):
├── W6: 物品栏系统
├── W7: 生存机制（饥饿、生命）
├── W8: 光照系统、天气/时间

Phase 4 (第9-11周):
├── W9: WebSocket 服务端
├── W10: 玩家/方块同步
├── W11: 聊天系统、测试
└── W12: 联调、Bug修复、发布
```

---

## 9. 术语表

| 术语       | 英文                   | 定义                                    |
| ---------- | ---------------------- | --------------------------------------- |
| 体素       | Voxel                  | 3D 空间中的最小单位，类似 2D 像素       |
| 区块       | Chunk                  | 32x32x32 的体素空间单位                 |
| 区块坐标   | ChunkKey               | 标识唯一区块的坐标 (x, y, z)            |
| 纹理图集   | TextureAtlas           | 多张纹理合并为一张图片，减少 draw calls |
| 视锥体剔除 | Frustum Culling        | 只渲染相机可见范围内的对象              |
| 层级细节   | LOD                    | 根据距离调整模型精度                    |
| 实例化渲染 | Instanced Rendering    | 一次绘制调用渲染多个相同对象            |
| 射线检测   | Raycasting             | 从相机发射射线检测碰撞点                |
| 噪声算法   | Noise Algorithm        | 生成自然随机地形（Perlin/Simplex）      |
| 串扰       | Z-fighting             | 两个面重叠时的闪烁现象                  |
| 帧率       | FPS                    | Frames Per Second，渲染帧率             |
| 首屏加载   | First Contentful Paint | 首次渲染有内容的时间                    |

---

## 10. 版本历史

| 版本 | 日期       | 变更                                           |
| ---- | ---------- | ---------------------------------------------- |
| 2.0  | 2026-02-08 | 初始版本                                       |
| 2.1  | 2026-02-08 | 补充用户场景、验收标准、技术依赖、排期、术语表 |

---

## 参考资料

- [Three.js 官方文档](https://threejs.org/docs/)
- [原项目 (backup/project_1.0)](./backup/project_1.0/)
- [Minecraft Wiki](https://minecraft.fandom.com/wiki/Minecraft_Wiki)
- [wiki.vg Protocol](https://wiki.vg/Protocol) - Minecraft 网络协议文档
- [Minecraft Pathfinding](https://github.com/Minecraft-Pathfinding/minecraft-pathfinding) - 生物寻路算法

---

## 13. 官方实现参考

> 以下内容基于对《我的世界》官方实现和开源社区研究的调研结果

### 13.1 方块系统实现

#### 13.1.1 Block ID 与 Block State 分离

Minecraft 使用**Block ID + Block State**的双层系统：

```
┌─────────────────────────────────────────────────────────┐
│                    方块系统架构                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Block ID（基础类型）                                    │
│  ├── 例如：minecraft:oak_log                           │
│  ├── 定义：基础属性、材质、默认行为                       │
│  └── 运行时仅存在一个实例                                 │
│                                                         │
│  Block State（运行时状态）                                │
│  ├── axis (vertical/horizontal)                         │
│  ├── rotation (0-3)                                    │
│  ├── powered (true/false)                              │
│  ├── age (0-15)                                        │
│  └── waterlogged (true/false)                          │
│                                                         │
│  示例：                                                  │
│  minecraft:oak_log[axis=x]                              │
│  minecraft:door[hinge=left,facing=east,open=true]       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**实现建议**：

```typescript
// 基础方块定义
interface BlockDefinition {
  id: string; // 唯一标识
  name: string; // 显示名称
  material: MaterialType; // 材质类型
  hardness: number; // 硬度
  resistance: number; // 爆炸抗性
  transparent: boolean; // 是否透明
  renderLayer: RenderLayer; // 渲染层级
  properties: BlockProperty[]; // 支持的属性
}

// 运行时方块状态
interface BlockState {
  blockId: string; // 关联的 Block ID
  properties: Record<string, any>; // 运行时属性值
}
```

#### 13.1.2 Tile Entity（方块实体）

用于存储超出 Block State 能力的动态数据：

| 用途     | 示例                 |
| -------- | -------------------- |
| 容器存储 | 箱子、漏斗、熔炉     |
| 复杂状态 | 音符盒音符、命令方块 |
| 定时行为 | 投掷器、活塞         |
| 渲染扩展 | 旗帜图案、物品展示框 |

### 13.2 地形生成算法

#### 13.2.1 多层噪声系统

Minecraft 使用**级联噪声**（Cascaded Noise）生成地形：

```
┌─────────────────────────────────────────────────────────┐
│              Minecraft 地形生成管线                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 基础噪声（Continentalness）                         │
│     └── 大陆/海洋轮廓                                    │
│           ↓                                             │
│  2. 侵蚀噪声（Erosion）                                 │
│     └── 地形细节、峡谷                                   │
│           ↓                                             │
│  3. 凹凸噪声（ Weirdness / Peaks & Valleys）            │
│     └── 山脉/山谷分布                                    │
│           ↓                                             │
│  4. 深度噪声（Depth）                                   │
│     └── 地面起伏、洞穴入口                               │
│           ↓                                             │
│  5. 基础高度 + 调节因子 = 最终高度                        │
│                                                         │
│  叠加生物群系边界检查                                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**推荐噪声库**：

| 库名               | 特点             | 链接                             |
| ------------------ | ---------------- | -------------------------------- |
| simplex-noise      | 高性能、MIT 许可 | `npm install simplex-noise`      |
| noisejs            | 简单易用         | `npm install noisejs`            |
| open-simplex-noise | 更自然的噪声     | `npm install open-simplex-noise` |

#### 13.2.2 生物群系系统

```
生物群系判定流程：

┌──────────────┐
│ 获取坐标 (x,z) │
└──────┬───────┘
       ↓
┌──────┴───────┐
│ 1. 获取温度 (Temperature)        │  ←  基础噪声
│ 2. 获取湿度 (Humidity)          │  ←  基础噪声
│ 3. 获取大陆度 (Continentalness) │  ←  基础噪声
│ 4. 获取侵蚀度 (Erosion)         │  ←  基础噪声
│ 5. 深度/偏移 (Depth/Weirdness)  │  ←  基础噪声
└──────┬───────┘
       ↓
┌──────┴───────┐
│  组合条件判定生物群系              │
│                                     │
│  温度 > 0.9 → 沙漠/沙漠丘陵        │
│  温度 0.6-0.9 → 平原/向日葵平原    │
│  温度 0.3-0.6 → 森林/桦木森林      │
│  温度 < 0.3 → 雪原/冰刺平原        │
│                                     │
│  湿度高 → 沼泽                     │
│  湿度低 → 恶地                     │
└──────┬───────┘
       ↓
┌──────┴───────┐
│  返回生物群系ID  │
└───────────────┘
```

### 13.3 光照系统实现

#### 13.3.1 双光照模型

Minecraft 使用两种独立的光照值（0-15）：

| 光照类型        | 来源        | 传播规则               |
| --------------- | ----------- | ---------------------- |
| **Sky Light**   | 天空        | 每格-1，可穿透透明方块 |
| **Block Light** | 火把/熔炉等 | 每格-1，不透明阻挡     |

**光照传播算法**（BFS 泛洪填充）：

```typescript
interface LightData {
  skyLight: number[]; // [y][x][z] = 0-15
  blockLight: number[]; // [y][x][z] = 0-15
}

// 更新流程
function updateBlockLight(world: World, pos: BlockPos, lightLevel: number) {
  const queue: BlockPos[] = [{ ...pos, light: lightLevel }];

  while (queue.length > 0) {
    const current = queue.shift()!;

    for (const neighbor of getNeighbors(current)) {
      const newLevel = current.light - 1;

      if (newLevel < world.getBlockLight(neighbor) && newLevel >= 0) {
        world.setBlockLight(neighbor, newLevel);
        queue.push({ ...neighbor, light: newLevel });
      }
    }
  }
}
```

#### 13.3.2 面剔除与渲染优化

```
渲染优化优先级：

┌─────────────────────────────────────────────────────────┐
│  1. 视锥体剔除（Frustum Culling）                       │
│     - 相机视野外的区块不渲染                              │
│     - Three.js 内置支持                                  │
│                                                         │
│  2. 面剔除（Face Culling）                              │
│     - 相邻方块遮挡的面不生成                              │
│     - 减少 60-70% 的三角形                               │
│                                                         │
│  3. 几何合并（Geometry Merging）                         │
│     - 相同材质的可见面合并为单一 Mesh                    │
│     - 显著减少 Draw Calls                                │
│                                                         │
│  4. 实例化渲染（Instanced Rendering）                    │
│     - 相同几何体一次 Draw Call                          │
│     - 适合大量同类型方块                                  │
│                                                         │
│  5. 贪婪网格（Greedy Meshing）                          │
│     - 合并相邻同材质面为矩形                             │
│     - 进阶优化，可减少 90%+ 面数                          │
└─────────────────────────────────────────────────────────┘
```

**性能对比**（参考开源实现）：

| 方法       | 面数（16×16×16 实心区块） | FPS   |
| ---------- | ------------------------- | ----- |
| 原始立方体 | 24,576                    | < 10  |
| 面剔除     | ~800                      | 30-40 |
| 几何合并   | ~1,536                    | 50-60 |
| 贪婪网格   | ~500                      | 60+   |

### 13.4 生物 AI 系统

#### 13.4.1 AI 架构（Goals + Memory）

```
┌─────────────────────────────────────────────────────────┐
│                    生物 AI 架构                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Brain（大脑）                                          │
│  ├── Sensors（感知器）                                   │
│  │   ├── PlayerSensor（感知玩家）                        │
│  │   ├── BlockSensor（感知方块）                         │
│  │   └── ItemSensor（感知物品）                          │
│  │                                                       │
│  ├── Memory（记忆）                                      │
│  │   ├── 最近看到玩家位置                                 │
│  │   ├── 家园位置                                       │
│  │   └── 攻击目标                                       │
│  │                                                       │
│  └── Tasks / Goals（任务）                               │
│      ├── 优先级 1：逃离危险                             │
│      ├── 优先级 2：追逐目标                             │
│      ├── 优先级 3：寻找食物                             │
│      └── 优先级 4：随机游荡                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 13.4.2 寻路系统（基于 A\*）

```
寻路算法流程：

┌──────────────┐
│ 1. 确定起点和终点 │
└──────┬───────┘
       ↓
┌──────┴───────┐
│ 2. 计算路径代价  │
│               │
│  代价公式：     │
│  cost =       │
│    base_cost  │
│  + jump_cost  │
│  + liquid_cost│
│  + danger_pen │
└──────┬───────┘
       ↓
┌──────┴───────┐
│ 3. A* 搜索    │
│              │
│  - 开放列表   │
│  - 关闭列表   │
│  - 启发函数   │
└──────┬───────┘
       ↓
┌──────┴───────┐
│ 4. 返回路径点  │
└──────────────┘
```

**方块通行代价**：

| 方块类型  | 代价 | 惩罚         |
| --------- | ---- | ------------ |
| 空气      | 0    | -            |
| 草地/泥土 | 1    | -            |
| 水        | 2    | 额外液体惩罚 |
| 岩浆      | -1   | 禁止通行     |
| 火        | -1   | 禁止通行     |
| 梯子      | 1    | 可垂直移动   |
| 陷阱门    | 2    | 需要打开     |

### 13.5 游戏 Tick 系统

#### 13.5.1 Tick 循环

```
┌─────────────────────────────────────────────────────────┐
│                   Minecraft Tick 循环                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  游戏 Tick（20次/秒 = 50ms/tick）                       │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 1. 玩家更新                                        │   │
│  │    - 位置同步                                       │   │
│  │    - 输入处理                                       │   │
│  │    - 饥饿/生命值更新                                │   │
│  └─────────────────────────────────────────────────┘   │
│                         ↓                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 2. 世界更新                                        │   │
│  │    - 随机 Tick（作物生长、随机事件）                │   │
│  │    - 定时 Tick（红石、漏斗）                       │   │
│  │    - 区块加载/卸载                                  │   │
│  │    - 光照传播                                      │   │
│  └─────────────────────────────────────────────────┘   │
│                         ↓                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 3. 生物更新                                        │   │
│  │    - AI 决策                                       │   │
│  │    - 移动更新                                       │   │
│  │    - 攻击/死亡处理                                  │   │
│  └─────────────────────────────────────────────────┘   │
│                         ↓                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 4. 保存检查                                        │   │
│  │    - 自动保存（30秒间隔）                          │   │
│  │    - 区块脏标记处理                                │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 13.6 存档格式

#### 13.6.1 Anvil 格式结构

```
世界存档目录结构：

world/
├── level.dat              # 世界基本信息（种子、时间、玩家数据）
├── player.dat             # 玩家存档
├── session.lock           # 锁文件（防止并发写入）
├── DIM{维度}/
│   └── region/
│       ├── r.0.0.mca     # 区域文件（32×32 区块）
│       ├── r.0.1.mca
│       └── ...
└── data/
    ├── biomes.json       # 生物群系数据
    └── dimensions.json   # 维度定义
```

**区块数据格式（NBT）**：

```
Compound: Chunk Data
├── int8: DataVersion
├── int32: xPos (区块 X 坐标)
├── int32: zPos (区块 Z 坐标)
├── int64: LastUpdate (最后更新时间)
├── int64: InhabitedTime (玩家逗留时间)
├── List: Sections (16×16×16 方块区域)
│   └── Compound: Section
│       ├── int8: Y (Y 索引 0-15)
│       ├── List: Palette (方块状态映射表)
│       └── LongArray: BlockStates (压缩的方块 ID)
├── LongArray: BlockLight (方块光照 2048 字节)
├── LongArray: SkyLight (天空光照 2048 字节)
├── List: TileEntities (方块实体数据)
└── List: Entities (实体数据)
```

**空间填充曲线**（YZX 顺序）：

```
索引计算公式：index = (y * 16 + z) * 16 + x

好处：
- 局部性好，内存连续访问
- 适合 LZ 系列压缩
- 便于范围查询
```

### 13.7 网络协议

#### 13.7.1 WebSocket 消息格式

```
连接建立：
┌─────────────────────────────────────────────────────────┐
│  客户端 → 服务器                                          │
│  {                                                       │
│    "type": "handshake",                                  │
│    "protocol": 1,                                        │
│    "version": "2.0",                                     │
│    "sessionId": "xxx"                                    │
│  }                                                       │
├─────────────────────────────────────────────────────────┤
│  服务器 → 客户端                                          │
│  {                                                       │
│    "type": "handshake_ack",                              │
│    "playerId": 1,                                        │
│    "serverTime": 1234567890                              │
│  }                                                       │
└─────────────────────────────────────────────────────────┘
```

**关键消息类型**：

| 消息类型       | 方向      | 用途          |
| -------------- | --------- | ------------- |
| `chunk_data`   | S→C       | 发送区块数据  |
| `block_update` | C→S / S→C | 方块放置/破坏 |
| `player_move`  | C→S / S→C | 玩家移动同步  |
| `entity_move`  | S→C       | 生物移动同步  |
| `chat_message` | C↔S       | 聊天消息      |
| `ping`         | C↔S       | 心跳保活      |

**压缩策略**：

```
┌─────────────────────────────────────────────────────────┐
│  消息压缩方案                                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 位置更新（高频）                                     │
│     - Delta 编码（只发送变化量）                          │
│     - 量化精度（浮点数 → 整数）                          │
│     - 示例：{dx: 0.1, dy: 0, dz: -0.05}                │
│                                                         │
│  2. 方块数据（中频）                                     │
│     - RLE 行程编码（连续相同值）                          │
│     - Palette 压缩（局部 ID 映射）                        │
│                                                         │
│  3. 大块数据（低频）                                     │
│     - 发送时 zlib 压缩                                   │
│     - WebSocket 帧压缩                                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 13.8 性能优化策略参考

#### 13.8.1 WebGL 优化清单

```
必须优化项：
├── Draw Calls
│   ├── 目标：< 100/帧
│   └── 方法：合并几何体、实例化渲染
│
├── 三角形数量
│   ├── 目标：< 100,000/帧
│   └── 方法：面剔除、贪婪网格
│
├── 内存占用
│   ├── 目标：< 500MB
│   └── 方法：对象池、延迟加载
│
└── 带宽占用
    ├── 目标：< 1MB/s
    └── 方法：增量更新、消息压缩
```

#### 13.8.2 推荐的 Three.js 优化库

| 库名                  | 用途            | 链接                         |
| --------------------- | --------------- | ---------------------------- |
| `three-mesh-bvh`      | 射线检测加速    | `npm install three-mesh-bvh` |
| `instanced-mesh`      | 实例化渲染增强  | `npm install instanced-mesh` |
| `bufferGeometryUtils` | 几何体合并      | Three.js 内置                |
| `offscreen-canvas`    | Web Worker 渲染 | 原生支持                     |

---

## 14. 实现优先级

### Phase 1 核心（必须）

- [ ] 基础方块渲染 + 面剔除
- [ ] 玩家移动 + AABB 碰撞检测
- [ ] 射线检测交互
- [ ] 基础噪声地形生成

### Phase 2 扩展（推荐）

- [ ] 光照系统
- [ ] 生物群系
- [ ] 贪婪网格优化
- [ ] 物品栏 UI

### Phase 3 增强（可选）

- [ ] 生物 AI 系统
- [ ] 完整生存机制
- [ ] 多人联机
- [ ] 世界存档

---

## 15. 架构设计模式

### 15.1 实体组件系统（ECS）

ECS 是一种将游戏对象分解为可复用部分来构建复杂应用的架构模式。

```
┌─────────────────────────────────────────────────────────┐
│                    ECS 架构                               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Entity（实体）                                          │
│  ├── 仅仅是 ID，不包含数据或行为                          │
│  ├── 组合不同组件来定义特征                              │
│  └── 示例：玩家、方块、生物                             │
│                                                         │
│  Component（组件）                                       │
│  ├── 数据容器，不包含逻辑                               │
│  ├── 示例：                                            │
│  │   ├── PositionComponent { x, y, z }                 │
│  │   ├── VelocityComponent { vx, vy, vz }              │
│  │   ├── HealthComponent { hp, maxHp }                │
│  │   ├── InventoryComponent { items: [] }              │
│  │   └── BlockStateComponent { type, metadata }        │
│                                                         │
│  System（系统）                                         │
│  ├── 处理特定逻辑，遍历实体                             │
│  ├── 示例：                                            │
│  │   ├── MovementSystem - 更新位置                      │
│  │   ├── CollisionSystem - 检测碰撞                    │
│  │   ├── RenderSystem - 渲染实体                      │
│  │   ├── AISystem - AI 决策                          │
│  │   └── LightingSystem - 更新光照                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**ECS 优势**：

- 数据局部性好，利于缓存
- 组合灵活，易于扩展
- 便于并行处理

### 15.2 事件驱动架构（EDA）

事件驱动架构允许系统在事件发生时检测、处理和管理。

```
┌─────────────────────────────────────────────────────────┐
│                  事件驱动流程                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 事件产生                                            │
│     ├── 用户输入（点击、按键）                           │
│     ├── 系统事件（时间、加载完成）                       │
│     └── 游戏事件（碰撞、死亡、建造）                     │
│           ↓                                            │
│  2. 事件分发                                           │
│     ├── 事件总线（EventBus）                            │
│     ├── 事件携带：类型、数据、时间戳                     │
│     └── 订阅者注册感兴趣的事件类型                       │
│           ↓                                            │
│  3. 事件处理                                           │
│     ├── 同步处理                                        │
│     └── 异步处理                                        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**实现示例**：

```typescript
// 事件定义
interface GameEvent {
  type: string;
  data: any;
  timestamp: number;
  source?: Entity;
}

// 事件总线
class EventBus {
  private listeners: Map<string, Listener[]> = new Map();

  on(eventType: string, callback: (event: GameEvent) => void): void;
  emit(eventType: string, data: any): void;
  off(eventType: string, callback: Function): void;
}

// 使用示例
eventBus.emit('block_place', {
  position: { x, y, z },
  blockType: 'stone',
  playerId: 'player_1',
});
```

### 15.3 插件系统设计

支持 modding 的游戏需要良好的插件架构。

```
┌─────────────────────────────────────────────────────────┐
│                  插件系统架构                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Core（核心）                                           │
│  ├── 游戏引擎                                            │
│  ├── API 接口                                           │
│  └── 事件系统                                           │
│                                                         │
│  Plugin Manager（插件管理器）                            │
│  ├── 插件发现                                           │
│  ├── 依赖解析                                           │
│  ├── 生命周期管理                                       │
│  └── 沙箱隔离                                           │
│                                                         │
│  Plugins（插件）                                        │
│  ├── 新方块                                            │
│  ├── 新生物                                             │
│  ├── 新物品                                             │
│  └── 游戏规则修改                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 16. 更多技术实现参考

### 16.1 输入系统设计

```
┌─────────────────────────────────────────────────────────┐
│                  输入抽象层                               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Input Manager                                          │
│  ├── Keyboard - 键盘状态映射                             │
│  ├── Mouse - 位置、按钮、滚轮                           │
│  ├── Touch - 触摸点、手势                                │
│  └── Gamepad - 手柄连接、轴、按钮                       │
│                                                         │
│  抽象绑定层                                             │
│  ├── 动作名称 → 物理输入映射                            │
│  │   └── "jump" → W键 / 手柄A按钮 / 触摸跳跃          │
│  ├── 组合键支持                                        │
│  │   └── "sprint_jump" → Shift + W                   │
│  └── 可配置的键位映射                                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 16.2 相机系统

Three.js 相机类型：

```
┌─────────────────────────────────────────────────────────┐
│                  Three.js 相机                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  PerspectiveCamera（透视相机）                           │
│  ├── 用于第一人称/第三人称游戏                          │
│  ├── FOV：视野角度（建议 60-90 度）                     │
│  ├── Aspect：宽高比                                    │
│  ├── Near：近裁剪面（建议 0.1）                        │
│  └── Far：远裁剪面（建议 1000+）                       │
│                                                         │
│  OrthographicCamera（正交相机）                          │
│  ├── 用于 2D UI、小地图                                │
│  ├── 物体大小不随距离变化                               │
│  └── 适合等距视角游戏                                   │
│                                                         │
│  控制器                                                 │
│  ├── PointerLockControls - 第一人称                     │
│  ├── OrbitControls - 轨道环绕                          │
│  └── FirstPersonControls - 飞行模式                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 16.3 纹理优化技术

```
┌─────────────────────────────────────────────────────────┐
│                  纹理优化策略                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Texture Atlas（纹理图集）                              │
│  ├── 将多个方块纹理合并为一张大图                        │
│  ├── 减少纹理切换次数                                   │
│  ├── UV 坐标映射到图集中的位置                           │
│                                                         │
│  Mipmap（多级纹理）                                     │
│  ├── 预先生成不同尺寸的纹理版本                          │
│  ├── 远距离使用低分辨率版本                              │
│  ├── 减少摩尔纹和闪烁                                    │
│                                                         │
│  Anisotropic Filtering（各向异性过滤）                   │
│  ├── 改善斜视角的纹理质量                               │
│  ├── 性能开销适中                                       │
│  └── WebGL 支持                                        │
│                                                         │
│  纹理压缩                                               │
│  ├── ETC2 - WebGL 2.0 原生支持                         │
│  ├── DXT - 需要扩展                                     │
│  └── Basis Universal - 跨平台压缩                        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 16.4 洞穴与结构生成

除了基础地形，程序化生成还包括特殊结构：

```
┌─────────────────────────────────────────────────────────┐
│                  特殊结构生成                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Cellular Automata（细胞自动机）                        │
│  └── 用于生成洞穴系统                                    │
│       ├── 随机填充网格（45% 实心）                      │
│       ├── 多次迭代平滑（相邻少于 4 实心则为空）          │
│       └── 连接空洞区域                                   │
│                                                         │
│  Perlin Noise Cave（噪声洞穴）                          │
│  └── 3D 噪声值 < 阈值 = 洞穴                           │
│       ├── 可控洞穴大小和密度                             │
│       └── 与地形高度叠加                                 │
│                                                         │
│  Structure Placement（结构放置）                         │
│  ├── 定义结构模板（预制体）                             │
│  ├── 随机选择生成位置                                   │
│  ├── 验证生成条件                                       │
│  └── 生成示例：                                          │
│       ├── 村庄（房屋、道路、村民）                       │
│       ├── 要塞（走廊、房间、蠹虫刷怪笼）                  │
│       ├── 废弃矿井（木头、蜘蛛网）                       │
│       └── 林地府邸（大师级建筑）                         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 16.5 AI 行为系统比较

```
┌─────────────────────────────────────────────────────────┐
│                FSM vs Behavior Tree                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Finite State Machine（有限状态机）                     │
│  ├── 简单、直接                                         │
│  ├── 状态和转换规则明确                                 │
│  ├── 适合：开关行为（门、灯）                           │
│  └── 示例：                                             │
│       IDLE → CHASE → ATTACK → IDLE                     │
│                                                         │
│  Behavior Tree（行为树）                                 │
│  ├── 层次化、模块化                                     │
│  ├── 可复用子树                                         │
│  ├── 适合：复杂 AI（怪物、村民）                         │
│  └── 节点类型：                                         │
│       ├── Selector（选择） - OR 逻辑                   │
│       ├── Sequence（序列）- AND 逻辑                    │
│       ├── Decorator（修饰）- 条件判断                   │
│       └── Action（动作）- 执行任务                      │
│                                                         │
│  选择指南：                                             │
│  ├── 少于 5 状态 → FSM                                 │
│  ├── 需要复杂决策 → Behavior Tree                       │
│  ├── 混合使用 → FSM 控制高層，BT 控制行為               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 16.6 存档与序列化

```
┌─────────────────────────────────────────────────────────┐
│                  存档策略                               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  序列化格式比较                                          │
│                                                         │
│  | 格式   | 优点                    | 缺点              |    │
│  |--------|-------------------------|-------------------|    │
│  | JSON   | 人类可读、易调试         | 体积大、解析慢    |    │
│  | Binary | 体积小、解析快           | 难以调试          |    │
│  | MessagePack | 体积小、可读        | 需要库支持        |    │
│  │ CBOR   | 体积小、标准格式          | 需要库支持        |    │
│                                                         │
│  增量保存                                               │
│  ├── 只保存修改的区块                                    │
│  ├── 定期自动保存（30 秒间隔）                           │
│  └── 世界快照（保存完整状态）                           │
│                                                         │
│  存档版本管理                                           │
│  ├── 版本号标记                                         │
│  ├── 向后兼容的数据迁移                                  │
│  └── 存档校验（checksum）                                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 16.7 碰撞检测技术

```
┌─────────────────────────────────────────────────────────┐
│                碰撞检测层次                              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Broad Phase（宽阶段）                                  │
│  ├── 快速排除明显不相交的对象                            │
│  ├── Octree（八叉树）                                   │
│  ├── BVH（包围体层次）                                  │
│  └── Spatial Hash Grid（空间哈希）                      │
│                                                         │
│  Narrow Phase（窄阶段）                                 │
│  ├── 精确检测相交                                        │
│  ├── AABB vs AABB                                      │
│  ├── Ray vs AABB（射线检测）                           │
│  └── Sphere vs Box                                      │
│                                                         │
│  Continuous vs Discrete                                 │
│  ├── Discrete - 每帧检查当前位置                         │
│  │   └── 快速，但可能穿模                                │
│  └── Continuous - 预测运动路径                            │
│       ├── Swept AABB                                    │
│       └── Time of Impact (TOI)                         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 17. 推荐学习资源

### 17.1 教程和课程

| 资源                                 | 链接                                       | 主题             |
| ------------------------------------ | ------------------------------------------ | ---------------- |
| Let's Make a Voxel Engine            | sites.google.com/site/letsmakeavoxelengine | Voxel 引擎全系列 |
| Sebastian Lague - Procedural Terrain | YouTube                                    | 地形生成教程     |
| Three.js Fundamentals                | threejs.org/docs                           | Three.js 基础    |
| Gaffer On Games                      | gafferongames.com                          | 游戏网络同步     |

### 17.2 开源项目

| 项目     | 链接                         | 说明               |
| -------- | ---------------------------- | ------------------ |
| Three.js | github.com/mrdoob/three.js   | 3D 渲染库          |
| Craft.js | github.com/craftjs/craftjs   | Web Minecraft 克隆 |
| Minetest | github.com/minetest/minetest | 开源体素游戏       |

### 17.3 学术论文

| 论文                           | 作者             | 主题         |
| ------------------------------ | ---------------- | ------------ |
| Simplex Noise Demystified      | Stefan Gustavson | Simplex 噪声 |
| Transvoxel Algorithm           | Eric Lengyel     | LOD 过渡算法 |
| Continuous Collision Detection | Brochu et al.    | 连续碰撞检测 |

---

## 版本历史

| 版本 | 日期       | 变更                                                                                                       |
| ---- | ---------- | ---------------------------------------------------------------------------------------------------------- |
| 2.0  | 2026-02-08 | 初始版本                                                                                                   |
| 2.1  | 2026-02-08 | 补充用户场景、验收标准、技术依赖、排期、术语表                                                             |
| 2.2  | 2026-02-08 | 补充官方实现参考（方块系统、地形生成、光照、AI、存档、协议）                                               |
| 2.3  | 2026-02-08 | 补充架构设计模式（ECS、EDA、插件系统）、输入系统、相机系统、纹理优化、结构生成、AI对比、存档策略、碰撞检测 |

---

## 相关文档

- [开发规范](./docs/DEVELOPMENT.md) - 代码风格、构建命令
- [部署文档](./docs/DEPLOYMENT.md) - GitHub Pages 部署
