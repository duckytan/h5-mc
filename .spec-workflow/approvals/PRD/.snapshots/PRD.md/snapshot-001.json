{
  "id": "snapshot_1770546350515_yilscantq",
  "approvalId": "approval_1770546350505_qaqgb38w8",
  "approvalTitle": "PRD 文档审批请求",
  "version": 1,
  "timestamp": "2026-02-08T10:25:50.515Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Minecraft H5 Web版 - 项目需求文档\n\n> 版本：2.0  \n> 状态：规划中  \n> 技术栈：Three.js + TypeScript + Vite  \n> 更新日期：2026-02-08\n\n---\n\n## 0. 用户场景\n\n### 典型用户故事\n\n**作为** 玩家  \n**我希望** 能够在浏览器中建造和探索  \n**以便** 随时随地体验体素建造的乐趣\n\n**作为** 开发者  \n**我希望** 项目代码结构清晰、易于维护  \n**以便** 快速迭代新功能\n\n### 核心用户流程\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                        用户流程图                           │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │\n│  │ 进入游戏  │ →  │ 生成世界  │ →  │ 自由探索  │             │\n│  └──────────┘    └──────────┘    └──────────┘             │\n│       │               │               │                    │\n│       ↓               ↓               ↓                    │\n│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │\n│  │ 选择模式  │    │ 放置方块  │    │ 与生物互动│             │\n│  │生存/创造 │    │ 破坏方块  │    │          │             │\n│  └──────────┘    └──────────┘    └──────────┘             │\n│       │               │               │                    │\n│       └───────────────┴───────────────┘                    │\n│                       ↓                                    │\n│                ┌──────────────┐                             │\n│                │ 保存/分享世界 │                             │\n│                └──────────────┘                             │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 1. 项目愿景\n\n打造一个高性能、可维护、支持多人联机的 Web 版体素沙盒游戏，提供接近原版 Minecraft 的核心体验，同时针对移动端和低配设备进行优化。\n\n---\n\n## 2. 核心功能需求\n\n### 2.1 世界生成\n\n- [ ] 无限地形生成（按需加载）\n- [ ] 多生物群系支持（森林、沙漠、平原、雪地等）\n- [ ] 地形特征（山脉、河流、洞穴）\n- [ ] 可配置的世界种子\n\n### 2.2 方块系统\n\n- [ ] 基础方块（石头、土、木头、沙子、水等）\n- [ ] 方块交互（放置、破坏）\n- [ ] 方块变体（不同木材、不同石头）\n- [ ] 方块物理属性（重力沙子、水流动）\n\n### 2.3 玩家系统\n\n- [ ] 第一人称视角控制\n- [ ] 移动（走、跑、跳跃、蹲下）\n- [ ] 物品栏管理\n- [ ] 生存模式（饥饿值、生命值）\n\n### 2.4 游戏机制\n\n- [ ] 时间系统（昼夜循环）\n- [ ] 天气系统（雨天、雪天）\n- [ ] 光照系统（方块阴影、火把光照）\n- [ ] 生物生成与AI\n\n### 2.5 多人联机\n\n- [ ] WebSocket 实时同步\n- [ ] 玩家位置同步\n- [ ] 方块变更同步\n- [ ] 聊天系统\n\n---\n\n## 3. 技术架构\n\n### 3.1 渲染引擎\n\n```\nThree.js\n├── VoxelWorld（体素世界管理）\n├── ChunkManager（区块管理）\n├── SceneManager（场景管理）\n└── MaterialManager（材质管理）\n```\n\n### 3.2 核心模块\n\n```\nsrc/\n├── core/           # 核心引擎\n│   ├── VoxelWorld.ts\n│   ├── ChunkManager.ts\n│   ├── SceneManager.ts\n│   └── MaterialManager.ts\n├── gameplay/       # 游戏玩法\n│   ├── PlayerController.ts\n│   └── BlockInteraction.ts\n├── world/          # 世界生成\n│   └── TerrainGenerator.ts\n└── ui/             # 用户界面\n    └── GameUI.ts\n```\n\n### 3.3 性能优化策略\n\n- [ ] 视锥体剔除（Frustum Culling）\n- [ ] 层级细节（LOD）\n- [ ] 实例化渲染（Instanced Rendering）\n- [ ] 按需加载区块\n- [ ] 材质合并\n- [ ] Web Worker 地形生成\n\n---\n\n## 4. 非功能需求\n\n### 4.1 性能指标\n\n- [ ] 60 FPS 桌面端\n- [ ] 30 FPS 移动端\n- [ ] 支持 1000+ 区块可视\n- [ ] 首屏加载 < 3 秒\n\n### 4.2 兼容性\n\n- [ ] Chrome / Firefox / Safari / Edge\n- [ ] iOS Safari / Android Chrome\n- [ ] 响应式 UI\n\n### 4.3 代码质量\n\n- [ ] TypeScript 严格模式\n- [ ] ESLint + Prettier\n- [ ] 单元测试覆盖率 > 70%\n- [ ] 完整的代码文档\n\n---\n\n## 5. 开发里程碑\n\n### Phase 1: 核心引擎（2周）\n\n- [ ] 搭建 Three.js 场景\n- [ ] 实现基础方块渲染\n- [ ] 玩家移动控制\n- [ ] 射线检测交互\n\n### Phase 2: 世界生成（2周）\n\n- [ ] 噪声算法地形生成\n- [ ] 多生物群系\n- [ ] 按需加载区块\n- [ ] 性能优化\n\n### Phase 3: 游戏玩法（2周）\n\n- [ ] 物品栏系统\n- [ ] 生存机制\n- [ ] 光照系统\n- [ ] 天气/时间\n\n### Phase 4: 联机功能（2周）\n\n- [ ] WebSocket 服务端\n- [ ] 玩家同步\n- [ ] 方块同步\n- [ ] 聊天系统\n\n---\n\n## 6. 风险与挑战\n\n| 风险 | 影响 | 缓解措施 |\n|------|------|----------|\n| 性能瓶颈 | 移动端卡顿 | LOD、实例化、按需加载 |\n| 代码复杂度 | 难以维护 | 模块化、严格类型、测试 |\n| 网络同步 | 延迟/冲突 | 乐观更新、冲突解决 |\n| 跨域兼容性 | 部分设备不支持 | 特性检测、回退方案 |\n\n### 6.1 验收标准\n\n#### 世界生成\n\n- [ ] 在 Chrome 桌面端生成 1000 区块耗时 < 5秒\n- [ ] 生物群系过渡自然（无明显接缝）\n- [ ] 种子系统可复现相同地形\n- [ ] 支持至少 4 种生物群系\n\n#### 方块系统\n\n- [ ] 支持至少 10 种基础方块\n- [ ] 方块放置/破坏延迟 < 100ms\n- [ ] 水方块正确流动（至少 3 格扩散）\n- [ ] 沙子方块正确受重力影响\n\n#### 玩家系统\n\n- [ ] WASD 移动响应延迟 < 50ms\n- [ ] 跳跃高度可配置\n- [ ] 物品栏支持至少 9 格\n- [ ] 生命值/饥饿值正确变化\n\n#### 性能指标\n\n- [ ] 桌面端 FPS ≥ 60\n- [ ] 移动端 FPS ≥ 30\n- [ ] 首屏加载 < 3 秒\n- [ ] 内存占用 < 500MB\n\n#### 联机功能（Phase 4）\n\n- [ ] 2+ 玩家同时在线\n- [ ] 位置同步延迟 < 200ms\n- [ ] 方块变更同步延迟 < 500ms\n- [ ] 断线重连成功恢复状态\n\n---\n\n## 7. 技术依赖\n\n### 7.1 核心依赖\n\n| 包名 | 版本 | 用途 |\n|------|------|------|\n| three.js | ^0.160.0 | 3D渲染引擎 |\n| vite | ^5.0.0 | 构建工具 |\n| typescript | ^5.3.0 | 类型安全 |\n| @types/three | ^0.160.0 | Three.js 类型定义 |\n\n### 7.2 可选依赖\n\n| 包名 | 用途 | 必要性 |\n|------|------|--------|\n| simplex-noise | 地形生成噪声算法 | 推荐 |\n| socket.io-client | 多人联机客户端 | Phase 4 |\n| socket.io | 多人联机服务端 | Phase 4 |\n| cannon-es | 物理引擎 | 可选 |\n| zstd-wasm | 数据压缩 | 可选（性能优化） |\n\n### 7.3 开发依赖\n\n| 包名 | 用途 |\n|------|------|\n| eslint | 代码检查 |\n| prettier | 代码格式化 |\n| vitest | 单元测试 |\n| @playwright/test | E2E 测试 |\n\n### 7.4 技术选型\n\n#### 渲染技术\n\n| 方面 | 选型 | 说明 |\n|------|------|------|\n| 渲染器 | WebGLRenderer | Three.js 默认渲染器 |\n| 材质 | MeshLambertMaterial + TextureAtlas | 性能与效果平衡 |\n| 光照 | AmbientLight + DirectionalLight | 支持阴影 |\n| 阴影 | PCFSoftShadowMap | 软阴影效果 |\n\n#### 数据结构\n\n| 方面 | 选型 | 说明 |\n|------|------|------|\n| 世界存储 | Map<ChunkKey, Uint8Array> | 区块坐标到数据 |\n| 方块数据 | Uint8Array (y * 32 + x * 1024 + z) | 线性存储 |\n| 玩家数据 | Object { position, inventory, health } | JSON 可序列化 |\n\n#### 网络协议\n\n| 方面 | 选型 | 说明 |\n|------|------|------|\n| 传输 | WebSocket | 实时双向通信 |\n| 消息格式 | JSON | 简单易调试 |\n| 压缩 | JSON + zstd（可选） | 大数据传输优化 |\n\n#### 存储方案\n\n| 场景 | 方案 | 限制 |\n|------|------|------|\n| 短期存档 | LocalStorage | 5MB 限制 |\n| 世界存档 | IndexedDB | 大容量存储 |\n| 联机存档 | 服务端数据库 | Redis + PostgreSQL |\n\n---\n\n## 8. 排期估算\n\n### 8.1 里程碑详细规划\n\n| Phase | 内容 | 预估工时 | 依赖 | 交付物 |\n|-------|------|---------|------|--------|\n| **Phase 0** | 项目初始化 | 1人天 | 无 | 完整项目结构、CI/CD |\n| **Phase 1** | 核心引擎 | 2人周 | Phase 0 | Three.js 场景、可移动视角 |\n| **Phase 2** | 世界生成 | 3人周 | Phase 1 | 可生成地形、多生物群系 |\n| **Phase 3** | 游戏玩法 | 3人周 | Phase 2 | 物品栏、生存机制 |\n| **Phase 4** | 联机功能 | 3人周 | Phase 3 | 多人实时同步 |\n\n**总计预估：11-12 人周**\n\n### 8.2 每周目标\n\n```\nPhase 1 (第1-2周):\n├── W1: 项目搭建、Three.js 场景、基础渲染\n├── W2: 玩家控制、射线检测、方块交互\n\nPhase 2 (第3-5周):\n├── W3: 噪声算法实现、地形生成\n├── W4: 多生物群系、区块加载\n├── W5: 性能优化（LOD、剔除）\n\nPhase 3 (第6-8周):\n├── W6: 物品栏系统\n├── W7: 生存机制（饥饿、生命）\n├── W8: 光照系统、天气/时间\n\nPhase 4 (第9-11周):\n├── W9: WebSocket 服务端\n├── W10: 玩家/方块同步\n├── W11: 聊天系统、测试\n└── W12: 联调、Bug修复、发布\n```\n\n---\n\n## 9. 术语表\n\n| 术语 | 英文 | 定义 |\n|------|------|------|\n| 体素 | Voxel | 3D 空间中的最小单位，类似 2D 像素 |\n| 区块 | Chunk | 32x32x32 的体素空间单位 |\n| 区块坐标 | ChunkKey | 标识唯一区块的坐标 (x, y, z) |\n| 纹理图集 | TextureAtlas | 多张纹理合并为一张图片，减少 draw calls |\n| 视锥体剔除 | Frustum Culling | 只渲染相机可见范围内的对象 |\n| 层级细节 | LOD | 根据距离调整模型精度 |\n| 实例化渲染 | Instanced Rendering | 一次绘制调用渲染多个相同对象 |\n| 射线检测 | Raycasting | 从相机发射射线检测碰撞点 |\n| 噪声算法 | Noise Algorithm | 生成自然随机地形（Perlin/Simplex） |\n| 串扰 | Z-fighting | 两个面重叠时的闪烁现象 |\n| 帧率 | FPS | Frames Per Second，渲染帧率 |\n| 首屏加载 | First Contentful Paint | 首次渲染有内容的时间 |\n\n---\n\n## 10. 版本历史\n\n| 版本 | 日期 | 变更 |\n|------|------|------|\n| 2.0 | 2026-02-08 | 初始版本 |\n| 2.1 | 2026-02-08 | 补充用户场景、验收标准、技术依赖、排期、术语表 |\n\n---\n\n## 参考资料\n\n- [Three.js 官方文档](https://threejs.org/docs/)\n- [原项目 (backup/project_1.0)](./backup/project_1.0/)\n- [Minecraft Wiki](https://minecraft.fandom.com/wiki/Minecraft_Wiki)\n- [wiki.vg Protocol](https://wiki.vg/Protocol) - Minecraft 网络协议文档\n- [Minecraft Pathfinding](https://github.com/Minecraft-Pathfinding/minecraft-pathfinding) - 生物寻路算法\n\n---\n\n## 13. 官方实现参考\n\n> 以下内容基于对《我的世界》官方实现和开源社区研究的调研结果\n\n### 13.1 方块系统实现\n\n#### 13.1.1 Block ID 与 Block State 分离\n\nMinecraft 使用**Block ID + Block State**的双层系统：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    方块系统架构                          │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Block ID（基础类型）                                    │\n│  ├── 例如：minecraft:oak_log                           │\n│  ├── 定义：基础属性、材质、默认行为                       │\n│  └── 运行时仅存在一个实例                                 │\n│                                                         │\n│  Block State（运行时状态）                                │\n│  ├── axis (vertical/horizontal)                         │\n│  ├── rotation (0-3)                                    │\n│  ├── powered (true/false)                              │\n│  ├── age (0-15)                                        │\n│  └── waterlogged (true/false)                          │\n│                                                         │\n│  示例：                                                  │\n│  minecraft:oak_log[axis=x]                              │\n│  minecraft:door[hinge=left,facing=east,open=true]       │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n**实现建议**：\n\n```typescript\n// 基础方块定义\ninterface BlockDefinition {\n  id: string;                    // 唯一标识\n  name: string;                  // 显示名称\n  material: MaterialType;         // 材质类型\n  hardness: number;              // 硬度\n  resistance: number;            // 爆炸抗性\n  transparent: boolean;          // 是否透明\n  renderLayer: RenderLayer;       // 渲染层级\n  properties: BlockProperty[];    // 支持的属性\n}\n\n// 运行时方块状态\ninterface BlockState {\n  blockId: string;               // 关联的 Block ID\n  properties: Record<string, any>; // 运行时属性值\n}\n```\n\n#### 13.1.2 Tile Entity（方块实体）\n\n用于存储超出 Block State 能力的动态数据：\n\n| 用途 | 示例 |\n|------|------|\n| 容器存储 | 箱子、漏斗、熔炉 |\n| 复杂状态 | 音符盒音符、命令方块 |\n| 定时行为 | 投掷器、活塞 |\n| 渲染扩展 | 旗帜图案、物品展示框 |\n\n### 13.2 地形生成算法\n\n#### 13.2.1 多层噪声系统\n\nMinecraft 使用**级联噪声**（Cascaded Noise）生成地形：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│              Minecraft 地形生成管线                       │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  1. 基础噪声（Continentalness）                         │\n│     └── 大陆/海洋轮廓                                    │\n│           ↓                                             │\n│  2. 侵蚀噪声（Erosion）                                 │\n│     └── 地形细节、峡谷                                   │\n│           ↓                                             │\n│  3. 凹凸噪声（ Weirdness / Peaks & Valleys）            │\n│     └── 山脉/山谷分布                                    │\n│           ↓                                             │\n│  4. 深度噪声（Depth）                                   │\n│     └── 地面起伏、洞穴入口                               │\n│           ↓                                             │\n│  5. 基础高度 + 调节因子 = 最终高度                        │\n│                                                         │\n│  叠加生物群系边界检查                                    │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n**推荐噪声库**：\n\n| 库名 | 特点 | 链接 |\n|------|------|------|\n| simplex-noise | 高性能、MIT 许可 | `npm install simplex-noise` |\n| noisejs | 简单易用 | `npm install noisejs` |\n| open-simplex-noise | 更自然的噪声 | `npm install open-simplex-noise` |\n\n#### 13.2.2 生物群系系统\n\n```\n生物群系判定流程：\n\n┌──────────────┐\n│ 获取坐标 (x,z) │\n└──────┬───────┘\n       ↓\n┌──────┴───────┐\n│ 1. 获取温度 (Temperature)        │  ←  基础噪声\n│ 2. 获取湿度 (Humidity)          │  ←  基础噪声\n│ 3. 获取大陆度 (Continentalness) │  ←  基础噪声\n│ 4. 获取侵蚀度 (Erosion)         │  ←  基础噪声\n│ 5. 深度/偏移 (Depth/Weirdness)  │  ←  基础噪声\n└──────┬───────┘\n       ↓\n┌──────┴───────┐\n│  组合条件判定生物群系              │\n│                                     │\n│  温度 > 0.9 → 沙漠/沙漠丘陵        │\n│  温度 0.6-0.9 → 平原/向日葵平原    │\n│  温度 0.3-0.6 → 森林/桦木森林      │\n│  温度 < 0.3 → 雪原/冰刺平原        │\n│                                     │\n│  湿度高 → 沼泽                     │\n│  湿度低 → 恶地                     │\n└──────┬───────┘\n       ↓\n┌──────┴───────┐\n│  返回生物群系ID  │\n└───────────────┘\n```\n\n### 13.3 光照系统实现\n\n#### 13.3.1 双光照模型\n\nMinecraft 使用两种独立的光照值（0-15）：\n\n| 光照类型 | 来源 | 传播规则 |\n|----------|------|----------|\n| **Sky Light** | 天空 | 每格-1，可穿透透明方块 |\n| **Block Light** | 火把/熔炉等 | 每格-1，不透明阻挡 |\n\n**光照传播算法**（BFS 泛洪填充）：\n\n```typescript\ninterface LightData {\n  skyLight: number[];   // [y][x][z] = 0-15\n  blockLight: number[]; // [y][x][z] = 0-15\n}\n\n// 更新流程\nfunction updateBlockLight(world: World, pos: BlockPos, lightLevel: number) {\n  const queue: BlockPos[] = [{...pos, light: lightLevel}];\n  \n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    \n    for (const neighbor of getNeighbors(current)) {\n      const newLevel = current.light - 1;\n      \n      if (newLevel < world.getBlockLight(neighbor) && newLevel >= 0) {\n        world.setBlockLight(neighbor, newLevel);\n        queue.push({...neighbor, light: newLevel});\n      }\n    }\n  }\n}\n```\n\n#### 13.3.2 面剔除与渲染优化\n\n```\n渲染优化优先级：\n\n┌─────────────────────────────────────────────────────────┐\n│  1. 视锥体剔除（Frustum Culling）                       │\n│     - 相机视野外的区块不渲染                              │\n│     - Three.js 内置支持                                  │\n│                                                         │\n│  2. 面剔除（Face Culling）                              │\n│     - 相邻方块遮挡的面不生成                              │\n│     - 减少 60-70% 的三角形                               │\n│                                                         │\n│  3. 几何合并（Geometry Merging）                         │\n│     - 相同材质的可见面合并为单一 Mesh                    │\n│     - 显著减少 Draw Calls                                │\n│                                                         │\n│  4. 实例化渲染（Instanced Rendering）                    │\n│     - 相同几何体一次 Draw Call                          │\n│     - 适合大量同类型方块                                  │\n│                                                         │\n│  5. 贪婪网格（Greedy Meshing）                          │\n│     - 合并相邻同材质面为矩形                             │\n│     - 进阶优化，可减少 90%+ 面数                          │\n└─────────────────────────────────────────────────────────┘\n```\n\n**性能对比**（参考开源实现）：\n\n| 方法 | 面数（16×16×16 实心区块） | FPS |\n|------|---------------------------|-----|\n| 原始立方体 | 24,576 | < 10 |\n| 面剔除 | ~800 | 30-40 |\n| 几何合并 | ~1,536 | 50-60 |\n| 贪婪网格 | ~500 | 60+ |\n\n### 13.4 生物 AI 系统\n\n#### 13.4.1 AI 架构（Goals + Memory）\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    生物 AI 架构                           │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Brain（大脑）                                          │\n│  ├── Sensors（感知器）                                   │\n│  │   ├── PlayerSensor（感知玩家）                        │\n│  │   ├── BlockSensor（感知方块）                         │\n│  │   └── ItemSensor（感知物品）                          │\n│  │                                                       │\n│  ├── Memory（记忆）                                      │\n│  │   ├── 最近看到玩家位置                                 │\n│  │   ├── 家园位置                                       │\n│  │   └── 攻击目标                                       │\n│  │                                                       │\n│  └── Tasks / Goals（任务）                               │\n│      ├── 优先级 1：逃离危险                             │\n│      ├── 优先级 2：追逐目标                             │\n│      ├── 优先级 3：寻找食物                             │\n│      └── 优先级 4：随机游荡                             │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n#### 13.4.2 寻路系统（基于 A*）\n\n```\n寻路算法流程：\n\n┌──────────────┐\n│ 1. 确定起点和终点 │\n└──────┬───────┘\n       ↓\n┌──────┴───────┐\n│ 2. 计算路径代价  │\n│               │\n│  代价公式：     │\n│  cost =       │\n│    base_cost  │\n│  + jump_cost  │\n│  + liquid_cost│\n│  + danger_pen │\n└──────┬───────┘\n       ↓\n┌──────┴───────┐\n│ 3. A* 搜索    │\n│              │\n│  - 开放列表   │\n│  - 关闭列表   │\n│  - 启发函数   │\n└──────┬───────┘\n       ↓\n┌──────┴───────┐\n│ 4. 返回路径点  │\n└──────────────┘\n```\n\n**方块通行代价**：\n\n| 方块类型 | 代价 | 惩罚 |\n|----------|------|------|\n| 空气 | 0 | - |\n| 草地/泥土 | 1 | - |\n| 水 | 2 | 额外液体惩罚 |\n| 岩浆 | -1 | 禁止通行 |\n| 火 | -1 | 禁止通行 |\n| 梯子 | 1 | 可垂直移动 |\n| 陷阱门 | 2 | 需要打开 |\n\n### 13.5 游戏 Tick 系统\n\n#### 13.5.1 Tick 循环\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                   Minecraft Tick 循环                     │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  游戏 Tick（20次/秒 = 50ms/tick）                       │\n│                                                         │\n│  ┌─────────────────────────────────────────────────┐   │\n│  │ 1. 玩家更新                                        │   │\n│  │    - 位置同步                                       │   │\n│  │    - 输入处理                                       │   │\n│  │    - 饥饿/生命值更新                                │   │\n│  └─────────────────────────────────────────────────┘   │\n│                         ↓                               │\n│  ┌─────────────────────────────────────────────────┐   │\n│  │ 2. 世界更新                                        │   │\n│  │    - 随机 Tick（作物生长、随机事件）                │   │\n│  │    - 定时 Tick（红石、漏斗）                       │   │\n│  │    - 区块加载/卸载                                  │   │\n│  │    - 光照传播                                      │   │\n│  └─────────────────────────────────────────────────┘   │\n│                         ↓                               │\n│  ┌─────────────────────────────────────────────────┐   │\n│  │ 3. 生物更新                                        │   │\n│  │    - AI 决策                                       │   │\n│  │    - 移动更新                                       │   │\n│  │    - 攻击/死亡处理                                  │   │\n│  └─────────────────────────────────────────────────┘   │\n│                         ↓                               │\n│  ┌─────────────────────────────────────────────────┐   │\n│  │ 4. 保存检查                                        │   │\n│  │    - 自动保存（30秒间隔）                          │   │\n│  │    - 区块脏标记处理                                │   │\n│  └─────────────────────────────────────────────────┘   │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 13.6 存档格式\n\n#### 13.6.1 Anvil 格式结构\n\n```\n世界存档目录结构：\n\nworld/\n├── level.dat              # 世界基本信息（种子、时间、玩家数据）\n├── player.dat             # 玩家存档\n├── session.lock           # 锁文件（防止并发写入）\n├── DIM{维度}/\n│   └── region/\n│       ├── r.0.0.mca     # 区域文件（32×32 区块）\n│       ├── r.0.1.mca\n│       └── ...\n└── data/\n    ├── biomes.json       # 生物群系数据\n    └── dimensions.json   # 维度定义\n```\n\n**区块数据格式（NBT）**：\n\n```\nCompound: Chunk Data\n├── int8: DataVersion\n├── int32: xPos (区块 X 坐标)\n├── int32: zPos (区块 Z 坐标)\n├── int64: LastUpdate (最后更新时间)\n├── int64: InhabitedTime (玩家逗留时间)\n├── List: Sections (16×16×16 方块区域)\n│   └── Compound: Section\n│       ├── int8: Y (Y 索引 0-15)\n│       ├── List: Palette (方块状态映射表)\n│       └── LongArray: BlockStates (压缩的方块 ID)\n├── LongArray: BlockLight (方块光照 2048 字节)\n├── LongArray: SkyLight (天空光照 2048 字节)\n├── List: TileEntities (方块实体数据)\n└── List: Entities (实体数据)\n```\n\n**空间填充曲线**（YZX 顺序）：\n\n```\n索引计算公式：index = (y * 16 + z) * 16 + x\n\n好处：\n- 局部性好，内存连续访问\n- 适合 LZ 系列压缩\n- 便于范围查询\n```\n\n### 13.7 网络协议\n\n#### 13.7.1 WebSocket 消息格式\n\n```\n连接建立：\n┌─────────────────────────────────────────────────────────┐\n│  客户端 → 服务器                                          │\n│  {                                                       │\n│    \"type\": \"handshake\",                                  │\n│    \"protocol\": 1,                                        │\n│    \"version\": \"2.0\",                                     │\n│    \"sessionId\": \"xxx\"                                    │\n│  }                                                       │\n├─────────────────────────────────────────────────────────┤\n│  服务器 → 客户端                                          │\n│  {                                                       │\n│    \"type\": \"handshake_ack\",                              │\n│    \"playerId\": 1,                                        │\n│    \"serverTime\": 1234567890                              │\n│  }                                                       │\n└─────────────────────────────────────────────────────────┘\n```\n\n**关键消息类型**：\n\n| 消息类型 | 方向 | 用途 |\n|----------|------|------|\n| `chunk_data` | S→C | 发送区块数据 |\n| `block_update` | C→S / S→C | 方块放置/破坏 |\n| `player_move` | C→S / S→C | 玩家移动同步 |\n| `entity_move` | S→C | 生物移动同步 |\n| `chat_message` | C↔S | 聊天消息 |\n| `ping` | C↔S | 心跳保活 |\n\n**压缩策略**：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│  消息压缩方案                                             │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  1. 位置更新（高频）                                     │\n│     - Delta 编码（只发送变化量）                          │\n│     - 量化精度（浮点数 → 整数）                          │\n│     - 示例：{dx: 0.1, dy: 0, dz: -0.05}                │\n│                                                         │\n│  2. 方块数据（中频）                                     │\n│     - RLE 行程编码（连续相同值）                          │\n│     - Palette 压缩（局部 ID 映射）                        │\n│                                                         │\n│  3. 大块数据（低频）                                     │\n│     - 发送时 zlib 压缩                                   │\n│     - WebSocket 帧压缩                                   │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 13.8 性能优化策略参考\n\n#### 13.8.1 WebGL 优化清单\n\n```\n必须优化项：\n├── Draw Calls\n│   ├── 目标：< 100/帧\n│   └── 方法：合并几何体、实例化渲染\n│\n├── 三角形数量\n│   ├── 目标：< 100,000/帧\n│   └── 方法：面剔除、贪婪网格\n│\n├── 内存占用\n│   ├── 目标：< 500MB\n│   └── 方法：对象池、延迟加载\n│\n└── 带宽占用\n    ├── 目标：< 1MB/s\n    └── 方法：增量更新、消息压缩\n```\n\n#### 13.8.2 推荐的 Three.js 优化库\n\n| 库名 | 用途 | 链接 |\n|------|------|------|\n| `three-mesh-bvh` | 射线检测加速 | `npm install three-mesh-bvh` |\n| `instanced-mesh` | 实例化渲染增强 | `npm install instanced-mesh` |\n| `bufferGeometryUtils` | 几何体合并 | Three.js 内置 |\n| `offscreen-canvas` | Web Worker 渲染 | 原生支持 |\n\n---\n\n## 14. 实现优先级\n\n### Phase 1 核心（必须）\n\n- [ ] 基础方块渲染 + 面剔除\n- [ ] 玩家移动 + AABB 碰撞检测\n- [ ] 射线检测交互\n- [ ] 基础噪声地形生成\n\n### Phase 2 扩展（推荐）\n\n- [ ] 光照系统\n- [ ] 生物群系\n- [ ] 贪婪网格优化\n- [ ] 物品栏 UI\n\n### Phase 3 增强（可选）\n\n- [ ] 生物 AI 系统\n- [ ] 完整生存机制\n- [ ] 多人联机\n- [ ] 世界存档\n\n---\n\n## 15. 架构设计模式\n\n### 15.1 实体组件系统（ECS）\n\nECS 是一种将游戏对象分解为可复用部分来构建复杂应用的架构模式。\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    ECS 架构                               │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Entity（实体）                                          │\n│  ├── 仅仅是 ID，不包含数据或行为                          │\n│  ├── 组合不同组件来定义特征                              │\n│  └── 示例：玩家、方块、生物                             │\n│                                                         │\n│  Component（组件）                                       │\n│  ├── 数据容器，不包含逻辑                               │\n│  ├── 示例：                                            │\n│  │   ├── PositionComponent { x, y, z }                 │\n│  │   ├── VelocityComponent { vx, vy, vz }              │\n│  │   ├── HealthComponent { hp, maxHp }                │\n│  │   ├── InventoryComponent { items: [] }              │\n│  │   └── BlockStateComponent { type, metadata }        │\n│                                                         │\n│  System（系统）                                         │\n│  ├── 处理特定逻辑，遍历实体                             │\n│  ├── 示例：                                            │\n│  │   ├── MovementSystem - 更新位置                      │\n│  │   ├── CollisionSystem - 检测碰撞                    │\n│  │   ├── RenderSystem - 渲染实体                      │\n│  │   ├── AISystem - AI 决策                          │\n│  │   └── LightingSystem - 更新光照                     │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n**ECS 优势**：\n- 数据局部性好，利于缓存\n- 组合灵活，易于扩展\n- 便于并行处理\n\n### 15.2 事件驱动架构（EDA）\n\n事件驱动架构允许系统在事件发生时检测、处理和管理。\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  事件驱动流程                             │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  1. 事件产生                                            │\n│     ├── 用户输入（点击、按键）                           │\n│     ├── 系统事件（时间、加载完成）                       │\n│     └── 游戏事件（碰撞、死亡、建造）                     │\n│           ↓                                            │\n│  2. 事件分发                                           │\n│     ├── 事件总线（EventBus）                            │\n│     ├── 事件携带：类型、数据、时间戳                     │\n│     └── 订阅者注册感兴趣的事件类型                       │\n│           ↓                                            │\n│  3. 事件处理                                           │\n│     ├── 同步处理                                        │\n│     └── 异步处理                                        │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n**实现示例**：\n\n```typescript\n// 事件定义\ninterface GameEvent {\n  type: string;\n  data: any;\n  timestamp: number;\n  source?: Entity;\n}\n\n// 事件总线\nclass EventBus {\n  private listeners: Map<string, Listener[]> = new Map();\n  \n  on(eventType: string, callback: (event: GameEvent) => void): void;\n  emit(eventType: string, data: any): void;\n  off(eventType: string, callback: Function): void;\n}\n\n// 使用示例\neventBus.emit('block_place', {\n  position: { x, y, z },\n  blockType: 'stone',\n  playerId: 'player_1'\n});\n```\n\n### 15.3 插件系统设计\n\n支持 modding 的游戏需要良好的插件架构。\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  插件系统架构                            │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Core（核心）                                           │\n│  ├── 游戏引擎                                            │\n│  ├── API 接口                                           │\n│  └── 事件系统                                           │\n│                                                         │\n│  Plugin Manager（插件管理器）                            │\n│  ├── 插件发现                                           │\n│  ├── 依赖解析                                           │\n│  ├── 生命周期管理                                       │\n│  └── 沙箱隔离                                           │\n│                                                         │\n│  Plugins（插件）                                        │\n│  ├── 新方块                                            │\n│  ├── 新生物                                             │\n│  ├── 新物品                                             │\n│  └── 游戏规则修改                                       │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 16. 更多技术实现参考\n\n### 16.1 输入系统设计\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  输入抽象层                               │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Input Manager                                          │\n│  ├── Keyboard - 键盘状态映射                             │\n│  ├── Mouse - 位置、按钮、滚轮                           │\n│  ├── Touch - 触摸点、手势                                │\n│  └── Gamepad - 手柄连接、轴、按钮                       │\n│                                                         │\n│  抽象绑定层                                             │\n│  ├── 动作名称 → 物理输入映射                            │\n│  │   └── \"jump\" → W键 / 手柄A按钮 / 触摸跳跃          │\n│  ├── 组合键支持                                        │\n│  │   └── \"sprint_jump\" → Shift + W                   │\n│  └── 可配置的键位映射                                   │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 16.2 相机系统\n\nThree.js 相机类型：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  Three.js 相机                          │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  PerspectiveCamera（透视相机）                           │\n│  ├── 用于第一人称/第三人称游戏                          │\n│  ├── FOV：视野角度（建议 60-90 度）                     │\n│  ├── Aspect：宽高比                                    │\n│  ├── Near：近裁剪面（建议 0.1）                        │\n│  └── Far：远裁剪面（建议 1000+）                       │\n│                                                         │\n│  OrthographicCamera（正交相机）                          │\n│  ├── 用于 2D UI、小地图                                │\n│  ├── 物体大小不随距离变化                               │\n│  └── 适合等距视角游戏                                   │\n│                                                         │\n│  控制器                                                 │\n│  ├── PointerLockControls - 第一人称                     │\n│  ├── OrbitControls - 轨道环绕                          │\n│  └── FirstPersonControls - 飞行模式                    │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 16.3 纹理优化技术\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  纹理优化策略                            │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Texture Atlas（纹理图集）                              │\n│  ├── 将多个方块纹理合并为一张大图                        │\n│  ├── 减少纹理切换次数                                   │\n│  ├── UV 坐标映射到图集中的位置                           │\n│                                                         │\n│  Mipmap（多级纹理）                                     │\n│  ├── 预先生成不同尺寸的纹理版本                          │\n│  ├── 远距离使用低分辨率版本                              │\n│  ├── 减少摩尔纹和闪烁                                    │\n│                                                         │\n│  Anisotropic Filtering（各向异性过滤）                   │\n│  ├── 改善斜视角的纹理质量                               │\n│  ├── 性能开销适中                                       │\n│  └── WebGL 支持                                        │\n│                                                         │\n│  纹理压缩                                               │\n│  ├── ETC2 - WebGL 2.0 原生支持                         │\n│  ├── DXT - 需要扩展                                     │\n│  └── Basis Universal - 跨平台压缩                        │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 16.4 洞穴与结构生成\n\n除了基础地形，程序化生成还包括特殊结构：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  特殊结构生成                            │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Cellular Automata（细胞自动机）                        │\n│  └── 用于生成洞穴系统                                    │\n│       ├── 随机填充网格（45% 实心）                      │\n│       ├── 多次迭代平滑（相邻少于 4 实心则为空）          │\n│       └── 连接空洞区域                                   │\n│                                                         │\n│  Perlin Noise Cave（噪声洞穴）                          │\n│  └── 3D 噪声值 < 阈值 = 洞穴                           │\n│       ├── 可控洞穴大小和密度                             │\n│       └── 与地形高度叠加                                 │\n│                                                         │\n│  Structure Placement（结构放置）                         │\n│  ├── 定义结构模板（预制体）                             │\n│  ├── 随机选择生成位置                                   │\n│  ├── 验证生成条件                                       │\n│  └── 生成示例：                                          │\n│       ├── 村庄（房屋、道路、村民）                       │\n│       ├── 要塞（走廊、房间、蠹虫刷怪笼）                  │\n│       ├── 废弃矿井（木头、蜘蛛网）                       │\n│       └── 林地府邸（大师级建筑）                         │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 16.5 AI 行为系统比较\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                FSM vs Behavior Tree                    │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Finite State Machine（有限状态机）                     │\n│  ├── 简单、直接                                         │\n│  ├── 状态和转换规则明确                                 │\n│  ├── 适合：开关行为（门、灯）                           │\n│  └── 示例：                                             │\n│       IDLE → CHASE → ATTACK → IDLE                     │\n│                                                         │\n│  Behavior Tree（行为树）                                 │\n│  ├── 层次化、模块化                                     │\n│  ├── 可复用子树                                         │\n│  ├── 适合：复杂 AI（怪物、村民）                         │\n│  └── 节点类型：                                         │\n│       ├── Selector（选择） - OR 逻辑                   │\n│       ├── Sequence（序列）- AND 逻辑                    │\n│       ├── Decorator（修饰）- 条件判断                   │\n│       └── Action（动作）- 执行任务                      │\n│                                                         │\n│  选择指南：                                             │\n│  ├── 少于 5 状态 → FSM                                 │\n│  ├── 需要复杂决策 → Behavior Tree                       │\n│  ├── 混合使用 → FSM 控制高層，BT 控制行為               │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 16.6 存档与序列化\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  存档策略                               │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  序列化格式比较                                          │\n│                                                         │\n│  | 格式   | 优点                    | 缺点              |    │\n│  |--------|-------------------------|-------------------|    │\n│  | JSON   | 人类可读、易调试         | 体积大、解析慢    |    │\n│  | Binary | 体积小、解析快           | 难以调试          |    │\n│  | MessagePack | 体积小、可读        | 需要库支持        |    │\n│  │ CBOR   | 体积小、标准格式          | 需要库支持        |    │\n│                                                         │\n│  增量保存                                               │\n│  ├── 只保存修改的区块                                    │\n│  ├── 定期自动保存（30 秒间隔）                           │\n│  └── 世界快照（保存完整状态）                           │\n│                                                         │\n│  存档版本管理                                           │\n│  ├── 版本号标记                                         │\n│  ├── 向后兼容的数据迁移                                  │\n│  └── 存档校验（checksum）                                │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 16.7 碰撞检测技术\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                碰撞检测层次                              │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Broad Phase（宽阶段）                                  │\n│  ├── 快速排除明显不相交的对象                            │\n│  ├── Octree（八叉树）                                   │\n│  ├── BVH（包围体层次）                                  │\n│  └── Spatial Hash Grid（空间哈希）                      │\n│                                                         │\n│  Narrow Phase（窄阶段）                                 │\n│  ├── 精确检测相交                                        │\n│  ├── AABB vs AABB                                      │\n│  ├── Ray vs AABB（射线检测）                           │\n│  └── Sphere vs Box                                      │\n│                                                         │\n│  Continuous vs Discrete                                 │\n│  ├── Discrete - 每帧检查当前位置                         │\n│  │   └── 快速，但可能穿模                                │\n│  └── Continuous - 预测运动路径                            │\n│       ├── Swept AABB                                    │\n│       └── Time of Impact (TOI)                         │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 17. 推荐学习资源\n\n### 17.1 教程和课程\n\n| 资源 | 链接 | 主题 |\n|------|------|------|\n| Let's Make a Voxel Engine | sites.google.com/site/letsmakeavoxelengine | Voxel 引擎全系列 |\n| Sebastian Lague - Procedural Terrain | YouTube | 地形生成教程 |\n| Three.js Fundamentals | threejs.org/docs | Three.js 基础 |\n| Gaffer On Games | gafferongames.com | 游戏网络同步 |\n\n### 17.2 开源项目\n\n| 项目 | 链接 | 说明 |\n|------|------|------|\n| Three.js | github.com/mrdoob/three.js | 3D 渲染库 |\n| Craft.js | github.com/craftjs/craftjs | Web Minecraft 克隆 |\n| Minetest | github.com/minetest/minetest | 开源体素游戏 |\n\n### 17.3 学术论文\n\n| 论文 | 作者 | 主题 |\n|------|------|------|\n| Simplex Noise Demystified | Stefan Gustavson | Simplex 噪声 |\n| Transvoxel Algorithm | Eric Lengyel | LOD 过渡算法 |\n| Continuous Collision Detection | Brochu et al. | 连续碰撞检测 |\n\n---\n\n## 版本历史\n\n| 版本 | 日期 | 变更 |\n|------|------|------|\n| 2.0 | 2026-02-08 | 初始版本 |\n| 2.1 | 2026-02-08 | 补充用户场景、验收标准、技术依赖、排期、术语表 |\n| 2.2 | 2026-02-08 | 补充官方实现参考（方块系统、地形生成、光照、AI、存档、协议） |\n| 2.3 | 2026-02-08 | 补充架构设计模式（ECS、EDA、插件系统）、输入系统、相机系统、纹理优化、结构生成、AI对比、存档策略、碰撞检测 |\n\n---\n\n## 相关文档\n\n- [开发规范](./docs/DEVELOPMENT.md) - 代码风格、构建命令\n- [部署文档](./docs/DEPLOYMENT.md) - GitHub Pages 部署\n",
  "fileStats": {
    "size": 57791,
    "lines": 1264,
    "lastModified": "2026-02-08T10:16:46.949Z"
  },
  "comments": []
}
